import argparse
import random
from include.partition import CGA
import ast

def get_args() -> argparse.Namespace:
   """
   Returns parsed command line arguments.

   The function uses the argparse library to parse the command line
   arguments. The available arguments are:

   * --file: the path to the output file
   * --n: the number of groups (default: [2, 3, 4, 5])
   * --m: the maximum number of values to generate (default: 20)
   * --b: the number of bits in each value (default: [4, 8, 16])
   * --repeat: the number of instances to generate for each configuration (default: 5)
   * --strategy: the strategy to use for generating the instances (default: "balanced", choices: ["balanced", "random"])

   Returns:
      argparse.Namespace: A namespace containing the parsed arguments.
   """
   parse = argparse.ArgumentParser(
      prog="Generate instances tool",
      description="Generate instances for the N-partition problem",
      epilog="Example: python3 generate-instances.py --file instances.txt --n [2, 3, 4, 5] --m 20 --b [4, 8, 16] --repeat 5 --strategy balanced"
   )
   parse.add_argument(
      "--file", 
      type=str, 
      required=True, 
      help="Path to output file"
   )
   parse.add_argument(
      "--n", 
      type=lambda s: ast.literal_eval(s), 
      required=False, 
      default=[2, 3, 4, 5], 
      help="Number of groups"
   )
   parse.add_argument(
      "--m", 
      type=int, 
      required=False, 
      default=20, 
      help="Maximum number of values to generate"
   )
   parse.add_argument(
      "--b", 
      type=lambda s: ast.literal_eval(s), 
      required=False, 
      default=[4, 8, 16], 
      help="Number of bits in each value"
   )
   parse.add_argument(
      "--repeat", 
      type=int, 
      required=False, 
      default=5, 
      help="Number of instances to generate for each configuration"
   )
   parse.add_argument(
      "--strategy", 
      type=str, 
      required=False, 
      default="balanced", 
      choices=["balanced", "random"], 
      help="Strategy to use for generating the instances. Must be one of 'balanced' or 'random'"
   )
   
   return parse.parse_args()

def balanced_strategy(
  n: int,
  m: int,
  b: int,
):
   """
   Generates a list of values such that the sum of each group is approximately
   balanced around the given target sum.

   The strategy works by first selecting a random target sum between
   lb and 2 * lb, then dividing the target sum by n to get the
   group sum. The group size is then calculated by dividing m by n
   and taking the remainder. The values are then generated by
   iteratively subtracting a random value from the remaining sum in
   each group.

   The result is a tuple containing the target sum and the list of
   generated values.

   Args:
      n (int): The number of groups to partition the values into.
      m (int): The number of values to generate.
      b (int): The number of bits in each value.

   Returns:
      tuple: A tuple containing the target sum and the list of generated
      values.
   """
   lb = 2 ** (b-1) * m
   total_sum = random.randint(lb, 2 * lb)
   q = m // n
   r = m % n
   group_sum = total_sum // n
   
   values = []
   
   for _ in range(n):
      if r > 0:
         group_size = q + 1
         r = r - 1
      else:
         group_size = q
      
      remaining_sum = group_sum
      
      for i in range(group_size):
         if i == group_size - 1:
            values.append(remaining_sum)
         else:
            value = random.randint(1, remaining_sum - (group_size - i - 1))
            values.append(value)
            remaining_sum -= value
   random.shuffle(values)
   return group_sum, values  
   
def random_strategy(
  n: int,
  m: int,
  b: int,
):
   """
   Generates an instance of the N-partition problem using a random strategy.

   Parameters:
   - n (int): The number of groups to partition the values into.
   - m (int): The number of values to generate.
   - b (int): The number of bits in each value.

   Returns:
   - tuple: A tuple containing the target sum and the list of generated
     values.
   """
   
   values = []
   
   for _ in range(m):
      value = random.randint(1, 2 ** b - 1)
      values.append(value)
   
   groups = CGA(values, n)
   makespan = max(map(sum, groups))
   
   return makespan, values

def generate(
   n: int,
   m: int,
   b: int,
   repeat: int,
   strategy: str,
):
   """
   Generates 'repeat' instances of the N-partition problem using the given
   strategy.

   Parameters:
   - n (int): The number of groups to partition the values into.
   - m (int): The number of values to generate.
   - b (int): The number of bits in each value.
   - repeat (int): The number of instances to generate.
   - strategy (str): The strategy to use for generating the instances.
   Must be one of "balanced" or "random".

   Returns:
   - list: A list of tuples, where each tuple contains the target sum
      and the list of generated values for an instance.
   """
   if strategy == "balanced":
      alg = balanced_strategy
   elif strategy == "random":
      alg = random_strategy
   else:
      raise ValueError("Invalid strategy")
   
   return [alg(n, m, b) for _ in range(repeat)]

def generate_instances(
  file_path,
  n_values=[2, 3, 4, 5],
  max_m=20,
  b_values=[4, 8, 16],
  repeat=5,
  strategy="balanced",
):
   """
   Generates N-partition problem instances using the given strategy and saves them to a file.

   Parameters:
   - file_path (str): Path to the output file.
   - n_values (list[int]): List of values for N.
   - max_m (int): Upper bound for the number of values to generate (M).
   - b_values (list[int]): List of values for the number of bits in each value (B).
   - repeat (int): Number of instances to generate for each configuration.
   - strategy (str): Strategy to use for generating the instances. Must be one of "balanced" or "random".
   """
   instance_id = 1
   with open(file_path, "w") as f:
      for n in n_values:
         for m in range(n, max_m + 1):
            for b in b_values:
               instances = generate(n, m, b, repeat, strategy)
               for makespan, values in instances:
                  f.write(f"# Instance {instance_id}\n")
                  f.write(f"{m} {n} {b} {makespan}\n")
                  f.write(" ".join(map(str, values)) + "\n\n")
                  instance_id += 1

if __name__ == "__main__":
   args = get_args()
   generate_instances(args.file, args.n, args.m, args.b, args.repeat, args.strategy)